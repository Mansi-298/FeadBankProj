bankRoutes
// routes/bankRoutes.js
const express = require('express');
const router = express.Router();
const Bank = require('../models/Bank');
const { generateTransactionData } = require('../utils/mlUtils');

// Get all banks
router.get('/', async (req, res) => {
  try {
    const banks = await Bank.find();
    res.json({
      success: true,
      count: banks.length,
      data: banks
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get single bank with transactions
router.get('/:id', async (req, res) => {
  try {
    const bank = await Bank.findById(req.params.id);
    
    if (!bank) {
      return res.status(404).json({
        success: false,
        error: 'Bank not found'
      });
    }
    
    res.json({
      success: true,
      data: bank
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Create new bank
router.post('/', async (req, res) => {
  try {
    const { name, color, transactionCount } = req.body;
    
    // Check if bank already exists
    const existingBank = await Bank.findOne({ name });
    if (existingBank) {
      return res.status(400).json({
        success: false,
        error: 'Bank with this name already exists'
      });
    }
    
    // Generate synthetic transaction data
    const transactions = generateTransactionData(name, transactionCount || 100);
    
    const bank = await Bank.create({
      name,
      color: color || '#3B82F6',
      transactions,
      localModel: {
        weights: {
          w1: Math.random() * 0.1,
          w2: Math.random() * 0.1,
          w3: Math.random() * 0.1,
          bias: Math.random() * 0.1
        },
        lastUpdated: new Date()
      }
    });
    
    res.status(201).json({
      success: true,
      data: bank
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Initialize demo banks
router.post('/init-demo', async (req, res) => {
  try {
    // Delete existing banks
    await Bank.deleteMany({});
    
    const demoBanks = [
      { name: 'Bank A', color: '#3B82F6', transactionCount: 100 },
      { name: 'Bank B', color: '#10B981', transactionCount: 120 },
      { name: 'Bank C', color: '#F59E0B', transactionCount: 80 }
    ];
    
    const createdBanks = [];
    
    for (const bankData of demoBanks) {
      const transactions = generateTransactionData(bankData.name, bankData.transactionCount);
      
      const bank = await Bank.create({
        name: bankData.name,
        color: bankData.color,
        transactions,
        localModel: {
          weights: {
            w1: Math.random() * 0.1,
            w2: Math.random() * 0.1,
            w3: Math.random() * 0.1,
            bias: Math.random() * 0.1
          },
          lastUpdated: new Date()
        }
      });
      
      createdBanks.push(bank);
    }
    
    res.status(201).json({
      success: true,
      message: 'Demo banks initialized successfully',
      data: createdBanks
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Update bank statistics
router.patch('/:id/statistics', async (req, res) => {
  try {
    const { currentAccuracy } = req.body;
    
    const bank = await Bank.findByIdAndUpdate(
      req.params.id,
      { 'statistics.currentAccuracy': currentAccuracy },
      { new: true }
    );
    
    if (!bank) {
      return res.status(404).json({
        success: false,
        error: 'Bank not found'
      });
    }
    
    res.json({
      success: true,
      data: bank
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Delete bank
router.delete('/:id', async (req, res) => {
  try {
    const bank = await Bank.findByIdAndDelete(req.params.id);
    
    if (!bank) {
      return res.status(404).json({
        success: false,
        error: 'Bank not found'
      });
    }
    
    res.json({
      success: true,
      message: 'Bank deleted successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router;

modelRoutes
// routes/modelRoutes.js
const express = require('express');
const router = express.Router();
const GlobalModel = require('../models/GlobalModel');
const Bank = require('../models/Bank');
const { FraudDetectionModel } = require('../utils/mlUtils');

// Get current active global model
router.get('/current', async (req, res) => {
  try {
    const globalModel = await GlobalModel.findOne({ isActive: true })
      .populate('trainingRoundId');
    
    if (!globalModel) {
      return res.status(404).json({
        success: false,
        error: 'No active global model found'
      });
    }
    
    res.json({
      success: true,
      data: globalModel
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get all model versions
router.get('/versions', async (req, res) => {
  try {
    const { limit = 10 } = req.query;
    
    const models = await GlobalModel.find()
      .sort('-version')
      .limit(parseInt(limit));
    
    res.json({
      success: true,
      count: models.length,
      data: models
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get specific model version
router.get('/version/:version', async (req, res) => {
  try {
    const model = await GlobalModel.findOne({ 
      version: parseInt(req.params.version) 
    }).populate('trainingRoundId');
    
    if (!model) {
      return res.status(404).json({
        success: false,
        error: 'Model version not found'
      });
    }
    
    res.json({
      success: true,
      data: model
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Evaluate model on bank data
router.post('/evaluate', async (req, res) => {
  try {
    const { bankId, modelVersion } = req.body;
    
    // Get bank
    const bank = await Bank.findById(bankId);
    if (!bank) {
      return res.status(404).json({
        success: false,
        error: 'Bank not found'
      });
    }
    
    // Get model
    let model;
    if (modelVersion) {
      model = await GlobalModel.findOne({ version: modelVersion });
    } else {
      model = await GlobalModel.findOne({ isActive: true });
    }
    
    if (!model) {
      return res.status(404).json({
        success: false,
        error: 'Model not found'
      });
    }
    
    // Evaluate
    const fraudModel = new FraudDetectionModel(model.weights);
    const accuracy = fraudModel.evaluate(bank.transactions);
    
    // Get per-class metrics
    let truePositives = 0;
    let trueNegatives = 0;
    let falsePositives = 0;
    let falseNegatives = 0;
    
    bank.transactions.forEach(txn => {
      const prediction = fraudModel.predict({
        amount: txn.amount,
        time: txn.time,
        location: txn.location
      });
      const predictedClass = prediction > 0.5 ? 1 : 0;
      
      if (predictedClass === 1 && txn.isFraud === 1) truePositives++;
      else if (predictedClass === 0 && txn.isFraud === 0) trueNegatives++;
      else if (predictedClass === 1 && txn.isFraud === 0) falsePositives++;
      else if (predictedClass === 0 && txn.isFraud === 1) falseNegatives++;
    });
    
    const precision = truePositives / (truePositives + falsePositives) || 0;
    const recall = truePositives / (truePositives + falseNegatives) || 0;
    const f1Score = 2 * (precision * recall) / (precision + recall) || 0;
    
    res.json({
      success: true,
      data: {
        bankName: bank.name,
        modelVersion: model.version,
        accuracy: accuracy.toFixed(2),
        metrics: {
          truePositives,
          trueNegatives,
          falsePositives,
          falseNegatives,
          precision: (precision * 100).toFixed(2),
          recall: (recall * 100).toFixed(2),
          f1Score: (f1Score * 100).toFixed(2)
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Predict fraud for new transaction
router.post('/predict', async (req, res) => {
  try {
    const { amount, time, location, modelVersion } = req.body;
    
    if (amount === undefined || time === undefined || location === undefined) {
      return res.status(400).json({
        success: false,
        error: 'Missing transaction features (amount, time, location)'
      });
    }
    
    // Get model
    let model;
    if (modelVersion) {
      model = await GlobalModel.findOne({ version: modelVersion });
    } else {
      model = await GlobalModel.findOne({ isActive: true });
    }
    
    if (!model) {
      return res.status(404).json({
        success: false,
        error: 'Model not found'
      });
    }
    
    // Make prediction
    const fraudModel = new FraudDetectionModel(model.weights);
    const probability = fraudModel.predict({ amount, time, location });
    const prediction = probability > 0.5 ? 'FRAUD' : 'NORMAL';
    
    res.json({
      success: true,
      data: {
        modelVersion: model.version,
        transaction: { amount, time, location },
        fraudProbability: (probability * 100).toFixed(2),
        prediction,
        confidence: (Math.abs(probability - 0.5) * 200).toFixed(2)
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Compare model versions
router.post('/compare', async (req, res) => {
  try {
    const { version1, version2, bankId } = req.body;
    
    const model1 = await GlobalModel.findOne({ version: version1 });
    const model2 = await GlobalModel.findOne({ version: version2 });
    
    if (!model1 || !model2) {
      return res.status(404).json({
        success: false,
        error: 'One or both model versions not found'
      });
    }
    
    let comparisonData = {
      version1: {
        version: model1.version,
        averageAccuracy: model1.performance.averageAccuracy
      },
      version2: {
        version: model2.version,
        averageAccuracy: model2.performance.averageAccuracy
      }
    };
    
    // If bankId provided, evaluate on specific bank
    if (bankId) {
      const bank = await Bank.findById(bankId);
      if (bank) {
        const fraudModel1 = new FraudDetectionModel(model1.weights);
        const fraudModel2 = new FraudDetectionModel(model2.weights);
        
        comparisonData.version1.bankAccuracy = fraudModel1.evaluate(bank.transactions);
        comparisonData.version2.bankAccuracy = fraudModel2.evaluate(bank.transactions);
        comparisonData.bankName = bank.name;
      }
    }
    
    res.json({
      success: true,
      data: comparisonData
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router;

traningRotes
// routes/trainingRoutes.js
const express = require('express');
const router = express.Router();
const Bank = require('../models/Bank');
const TrainingRound = require('../models/TrainingRound');
const GlobalModel = require('../models/GlobalModel');
const { FraudDetectionModel, federatedAveraging } = require('../utils/mlUtils');

// Start new training round
router.post('/start', async (req, res) => {
  try {
    const banks = await Bank.find();
    
    if (banks.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No banks available for training'
      });
    }
    
    // Get latest round number
    const latestRound = await TrainingRound.findOne().sort('-roundNumber');
    const roundNumber = latestRound ? latestRound.roundNumber + 1 : 1;
    
    // Create new training round
    const trainingRound = await TrainingRound.create({
      roundNumber,
      status: 'pending',
      startTime: new Date()
    });
    
    res.status(201).json({
      success: true,
      data: trainingRound
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Bank submits local training update
router.post('/submit-update', async (req, res) => {
  try {
    const { roundId, bankId, gradients, dataSize } = req.body;
    
    // Validate inputs
    if (!roundId || !bankId || !gradients || !dataSize) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields'
      });
    }
    
    // Find training round
    const trainingRound = await TrainingRound.findById(roundId);
    if (!trainingRound) {
      return res.status(404).json({
        success: false,
        error: 'Training round not found'
      });
    }
    
    // Find bank
    const bank = await Bank.findById(bankId);
    if (!bank) {
      return res.status(404).json({
        success: false,
        error: 'Bank not found'
      });
    }
    
    // Calculate accuracy
    const model = new FraudDetectionModel(bank.localModel.weights);
    model.updateWeights(gradients);
    const accuracy = model.evaluate(bank.transactions);
    
    // Update bank's local model
    bank.localModel.weights = model.getWeights();
    bank.localModel.lastUpdated = new Date();
    bank.statistics.currentAccuracy = accuracy;
    await bank.save();
    
    // Add update to training round
    trainingRound.bankUpdates.push({
      bankId: bank._id,
      bankName: bank.name,
      gradients,
      dataSize,
      accuracy,
      timestamp: new Date()
    });
    
    trainingRound.status = 'training';
    await trainingRound.save();
    
    res.json({
      success: true,
      data: {
        trainingRound,
        accuracy
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Aggregate updates and create global model
router.post('/aggregate/:roundId', async (req, res) => {
  try {
    const trainingRound = await TrainingRound.findById(req.params.roundId);
    
    if (!trainingRound) {
      return res.status(404).json({
        success: false,
        error: 'Training round not found'
      });
    }
    
    if (trainingRound.bankUpdates.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No bank updates to aggregate'
      });
    }
    
    // Update status
    trainingRound.status = 'aggregating';
    await trainingRound.save();
    
    // Perform federated averaging
    const avgGradients = federatedAveraging(trainingRound.bankUpdates);
    
    // Get current global model or create new one
    let currentGlobalModel = await GlobalModel.findOne({ isActive: true });
    
    const model = new FraudDetectionModel(
      currentGlobalModel ? currentGlobalModel.weights : undefined
    );
    model.updateWeights(avgGradients);
    const newWeights = model.getWeights();
    
    // Calculate average accuracy
    const avgAccuracy = trainingRound.bankUpdates.reduce(
      (sum, u) => sum + u.accuracy, 0
    ) / trainingRound.bankUpdates.length;
    
    const totalDataPoints = trainingRound.bankUpdates.reduce(
      (sum, u) => sum + u.dataSize, 0
    );
    
    // Create new global model version
    const newVersion = currentGlobalModel ? currentGlobalModel.version + 1 : 1;
    const globalModel = await GlobalModel.create({
      version: newVersion,
      weights: newWeights,
      performance: {
        averageAccuracy: avgAccuracy,
        participatingBanks: trainingRound.bankUpdates.length,
        totalDataPoints
      },
      trainingRoundId: trainingRound._id,
      isActive: true
    });
    
    // Update training round
    trainingRound.globalModel = {
      weights: newWeights,
      averageAccuracy: avgAccuracy,
      updatedAt: new Date()
    };
    trainingRound.status = 'completed';
    trainingRound.endTime = new Date();
    await trainingRound.save();
    
    res.json({
      success: true,
      data: {
        trainingRound,
        globalModel
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get training round history
router.get('/history', async (req, res) => {
  try {
    const { limit = 10 } = req.query;
    
    const history = await TrainingRound.find()
      .sort('-roundNumber')
      .limit(parseInt(limit))
      .select('-bankUpdates');
    
    res.json({
      success: true,
      count: history.length,
      data: history
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get specific training round details
router.get('/:roundId', async (req, res) => {
  try {
    const trainingRound = await TrainingRound.findById(req.params.roundId)
      .populate('bankUpdates.bankId', 'name color');
    
    if (!trainingRound) {
      return res.status(404).json({
        success: false,
        error: 'Training round not found'
      });
    }
    
    res.json({
      success: true,
      data: trainingRound
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get current training status
router.get('/status/current', async (req, res) => {
  try {
    const activeRound = await TrainingRound.findOne({
      status: { $in: ['pending', 'training', 'aggregating'] }
    }).sort('-roundNumber');
    
    const latestCompletedRound = await TrainingRound.findOne({
      status: 'completed'
    }).sort('-roundNumber');
    
    const globalModel = await GlobalModel.findOne({ isActive: true });
    
    res.json({
      success: true,
      data: {
        activeRound,
        latestCompletedRound,
        globalModel
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router;

mlUtils.js
// utils/mlUtils.js - Machine Learning Utilities
class FraudDetectionModel {
  constructor(weights = null) {
    if (weights) {
      this.weights = weights;
    } else {
      this.weights = {
        w1: Math.random() * 0.1,
        w2: Math.random() * 0.1,
        w3: Math.random() * 0.1,
        bias: Math.random() * 0.1
      };
    }
    this.learningRate = 0.01;
  }

  sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }

  predict(features) {
    const { amount, time, location } = features;
    const z = this.weights.w1 * amount + 
              this.weights.w2 * time + 
              this.weights.w3 * location + 
              this.weights.bias;
    return this.sigmoid(z);
  }

  train(data, epochs = 5) {
    const gradients = { w1: 0, w2: 0, w3: 0, bias: 0 };
    
    for (let epoch = 0; epoch < epochs; epoch++) {
      for (const sample of data) {
        const { amount, time, location, isFraud } = sample;
        const prediction = this.predict({ amount, time, location });
        const error = prediction - isFraud;

        gradients.w1 += error * amount;
        gradients.w2 += error * time;
        gradients.w3 += error * location;
        gradients.bias += error;
      }
    }

    // Average gradients
    const n = data.length * epochs;
    Object.keys(gradients).forEach(key => {
      gradients[key] /= n;
    });

    return gradients;
  }

  updateWeights(gradients) {
    this.weights.w1 -= this.learningRate * gradients.w1;
    this.weights.w2 -= this.learningRate * gradients.w2;
    this.weights.w3 -= this.learningRate * gradients.w3;
    this.weights.bias -= this.learningRate * gradients.bias;
  }

  evaluate(data) {
    let correct = 0;
    for (const sample of data) {
      const { amount, time, location, isFraud } = sample;
      const prediction = this.predict({ amount, time, location });
      const predictedClass = prediction > 0.5 ? 1 : 0;
      if (predictedClass === isFraud) correct++;
    }
    return correct / data.length; // Return decimal (0-1), not percentage
  }

  getWeights() {
    return { ...this.weights };
  }

  setWeights(weights) {
    this.weights = { ...weights };
  }
}

// Federated Averaging
function federatedAveraging(updates) {
  const totalData = updates.reduce((sum, u) => sum + u.dataSize, 0);
  const avgGradients = { w1: 0, w2: 0, w3: 0, bias: 0 };
  
  updates.forEach(update => {
    const weight = update.dataSize / totalData;
    Object.keys(avgGradients).forEach(key => {
      avgGradients[key] += update.gradients[key] * weight;
    });
  });
  
  return avgGradients;
}

// Generate synthetic transaction data
function generateTransactionData(bankId, size = 100) {
  const data = [];
  const fraudRate = 0.1 + Math.random() * 0.1; // 10-20% fraud rate
  
  for (let i = 0; i < size; i++) {
    const isFraud = Math.random() < fraudRate ? 1 : 0;
    
    data.push({
      transactionId: `${bankId}-txn-${Date.now()}-${i}`,
      amount: isFraud 
        ? Math.random() * 0.9 + 0.5  // High amounts for fraud (0.5-1.4)
        : Math.random() * 0.5,        // Normal amounts (0-0.5)
      time: isFraud
        ? Math.random() * 0.3         // Unusual times (0-0.3)
        : Math.random() * 0.5 + 0.3,  // Normal times (0.3-0.8)
      location: isFraud
        ? Math.random() * 0.9 + 0.5   // Unusual locations (0.5-1.4)
        : Math.random() * 0.5,        // Normal locations (0-0.5)
      isFraud
    });
  }
  
  return data;
}

module.exports = {
  FraudDetectionModel,
  federatedAveraging,
  generateTransactionData
};

server.js
// server.js - Main Express Server
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const dotenv = require('dotenv');

dotenv.config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// MongoDB Connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/federated_learning', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('âœ… MongoDB Connected'))
.catch(err => console.error('âŒ MongoDB Connection Error:', err));

// Import Routes
const bankRoutes = require('./routes/bankRoutes');
const trainingRoutes = require('./routes/trainingRoutes');
const modelRoutes = require('./routes/modelRoutes');

// Use Routes
app.use('/api/banks', bankRoutes);
app.use('/api/training', trainingRoutes);
app.use('/api/models', modelRoutes);

// Health Check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date() });
});

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
});